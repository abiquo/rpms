From 68b170579a7bade330e5e64c9248f5171e3a2d2f Mon Sep 17 00:00:00 2001
From: Alon Levy <alevy@redhat.com>
Date: Mon, 4 Apr 2011 10:30:16 -0300
Subject: [RHEL6 qemu-kvm PATCH 06/12] ccid: v18_upstream (v25) cleanup

RH-Author: Alon Levy <alevy@redhat.com>
Message-id: <1301913022-22142-7-git-send-email-alevy@redhat.com>
Patchwork-id: 21249
O-Subject: [PATCH RHEL6.1 v4 06/12] ccid: v18_upstream (v25) cleanup
Bugzilla: 641833
RH-Acked-by: Amit Shah <amit.shah@redhat.com>
RH-Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>
RH-Acked-by: Hans de Goede <hdegoede@redhat.com>

BZ: 641833

upstream: this is the diff between v18 and v25.

relevant parts from commit message from v25 upstream:

changes from v20->v21: (Jes Sorensen review)
 * cosmetic changes - fix multi line comments.
 * reorder fields in USBCCIDState
 * add reference to COPYING

changes from v19->v20:
 * checkpatch.pl

changes from v18->v19:
 * merged: ccid.h: add copyright, fix define and remove non C89 comments
 * add qdev.desc
---
 hw/ccid.h     |   23 ++-
 hw/usb-ccid.c |  604 +++++++++++++++++++++++++++++++-------------------------
 2 files changed, 350 insertions(+), 277 deletions(-)

Signed-off-by: Eduardo Habkost <ehabkost@redhat.com>
---
 hw/ccid.h     |   23 ++-
 hw/usb-ccid.c |  604 +++++++++++++++++++++++++++++++-------------------------
 2 files changed, 350 insertions(+), 277 deletions(-)

diff --git a/hw/ccid.h b/hw/ccid.h
index da02f1d..dbfc13c 100644
--- a/hw/ccid.h
+++ b/hw/ccid.h
@@ -15,35 +15,44 @@
 typedef struct CCIDCardState CCIDCardState;
 typedef struct CCIDCardInfo CCIDCardInfo;
 
-/* state of the CCID Card device (i.e. hw/ccid-card-*.c)
+/*
+ * state of the CCID Card device (i.e. hw/ccid-card-*.c)
  */
 struct CCIDCardState {
     DeviceState qdev;
     uint32_t    slot; /* For future use with multiple slot reader. */
 };
 
-/* callbacks to be used by the CCID device (hw/usb-ccid.c) to call
+/*
+ * callbacks to be used by the CCID device (hw/usb-ccid.c) to call
  * into the smartcard device (hw/ccid-card-*.c)
  */
 struct CCIDCardInfo {
     DeviceInfo qdev;
     void (*print)(Monitor *mon, CCIDCardState *card, int indent);
     const uint8_t *(*get_atr)(CCIDCardState *card, uint32_t *len);
-    void (*apdu_from_guest)(CCIDCardState *card, const uint8_t *apdu, uint32_t len);
+    void (*apdu_from_guest)(CCIDCardState *card,
+                            const uint8_t *apdu,
+                            uint32_t len);
     int (*exitfn)(CCIDCardState *card);
     int (*initfn)(CCIDCardState *card);
 };
 
-/* API for smartcard calling the CCID device (used by hw/ccid-card-*.c)
+/*
+ * API for smartcard calling the CCID device (used by hw/ccid-card-*.c)
  */
-void ccid_card_send_apdu_to_guest(CCIDCardState *card, uint8_t* apdu, uint32_t len);
+void ccid_card_send_apdu_to_guest(CCIDCardState *card,
+                                  uint8_t *apdu,
+                                  uint32_t len);
 void ccid_card_card_removed(CCIDCardState *card);
 void ccid_card_card_inserted(CCIDCardState *card);
 void ccid_card_card_error(CCIDCardState *card, uint64_t error);
 void ccid_card_qdev_register(CCIDCardInfo *card);
 
-/* support guest visible insertion/removal of ccid devices based on actual
- * devices connected/removed. Called by card implementation (passthru, local) */
+/*
+ * support guest visible insertion/removal of ccid devices based on actual
+ * devices connected/removed. Called by card implementation (passthru, local)
+ */
 int ccid_card_ccid_attach(CCIDCardState *card);
 void ccid_card_ccid_detach(CCIDCardState *card);
 
diff --git a/hw/usb-ccid.c b/hw/usb-ccid.c
index 15cb3d5..723b2e3 100644
--- a/hw/usb-ccid.c
+++ b/hw/usb-ccid.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010 Red Hat, Inc.
+ * Copyright (C) 2011 Red Hat, Inc.
  *
  * CCID Device emulation
  *
@@ -7,17 +7,16 @@
  *
  * Based on usb-serial.c, see it's copyright and attributions below.
  *
- * This code is licenced under the GNU LGPL, version 2 or later.
- *
- * -------
- *
- * usb-serial.c copyright and attribution:
+ * This work is licensed under the terms of the GNU GPL, version 2.1 or later.
+ * See the COPYING file in the top-level directory.
+ * ------- (original copyright & attribution for usb-serial.c below) --------
  * Copyright (c) 2006 CodeSourcery.
  * Copyright (c) 2008 Samuel Thibault <samuel.thibault@ens-lyon.org>
  * Written by Paul Brook, reused for FTDI by Samuel Thibault,
  */
 
-/* References:
+/*
+ * References:
  *
  * CCID Specification Revision 1.1 April 22nd 2005
  *  "Universal Serial Bus, Device Class: Smart Card"
@@ -33,7 +32,6 @@
  *  when a short packet is sent, as seen in uhci-usb.c, resulting from a urb
  *  from the guest requesting SPD and us returning a smaller packet.
  *  Not sure which messages trigger this.
- *
  */
 
 #include "qemu-common.h"
@@ -44,7 +42,11 @@
 #include "hw/ccid.h"
 
 #define DPRINTF(s, lvl, fmt, ...) \
-do { if (lvl <= s->debug) { printf("usb-ccid: " fmt , ## __VA_ARGS__); } } while (0)
+do { \
+    if (lvl <= s->debug) { \
+        printf("usb-ccid: " fmt , ## __VA_ARGS__); \
+    } \
+} while (0)
 
 #define D_WARN 1
 #define D_INFO 2
@@ -53,18 +55,23 @@ do { if (lvl <= s->debug) { printf("usb-ccid: " fmt , ## __VA_ARGS__); } } while
 
 #define CCID_DEV_NAME "usb-ccid"
 
-/* The two options for variable sized buffers:
+/*
+ * The two options for variable sized buffers:
  * make them constant size, for large enough constant,
  * or handle the migration complexity - VMState doesn't handle this case.
- * sizes are expected never to be exceeded, unless guest misbehaves. */
+ * sizes are expected never to be exceeded, unless guest misbehaves.
+ */
 #define BULK_OUT_DATA_SIZE 65536
 #define PENDING_ANSWERS_NUM 128
 
 #define BULK_IN_BUF_SIZE 384
 #define BULK_IN_PENDING_NUM 8
 
-#define InterfaceOutClass    ((USB_DIR_OUT|USB_TYPE_CLASS|USB_RECIP_INTERFACE)<<8)
-#define InterfaceInClass     ((USB_DIR_IN |USB_TYPE_CLASS|USB_RECIP_INTERFACE)<<8)
+#define InterfaceOutClass \
+    ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE)<<8)
+
+#define InterfaceInClass  \
+    ((USB_DIR_IN  | USB_TYPE_CLASS | USB_RECIP_INTERFACE)<<8)
 
 #define CCID_MAX_PACKET_SIZE                64
 
@@ -76,18 +83,20 @@ do { if (lvl <= s->debug) { printf("usb-ccid: " fmt , ## __VA_ARGS__); } } while
 #define CCID_VENDOR_DESCRIPTION         "QEMU " QEMU_VERSION
 #define CCID_INTERFACE_NAME             "CCID Interface"
 #define CCID_SERIAL_NUMBER_STRING       "1"
-/* Using Gemplus Vendor and Product id
-  Effect on various drivers:
-  * usbccid.sys (winxp, others untested) is a class driver so it doesn't care.
-  * linux has a number of class drivers, but openct filters based on
-    vendor/product (/etc/openct.conf under fedora), hence Gemplus.
+/*
+ * Using Gemplus Vendor and Product id
+ * Effect on various drivers:
+ *  usbccid.sys (winxp, others untested) is a class driver so it doesn't care.
+ *  linux has a number of class drivers, but openct filters based on
+ *   vendor/product (/etc/openct.conf under fedora), hence Gemplus.
  */
 #define CCID_VENDOR_ID                  0x08e6
 #define CCID_PRODUCT_ID                 0x4433
 #define CCID_DEVICE_VERSION             0x0000
 
-/* BULK_OUT messages from PC to Reader
-   Defined in CCID Rev 1.1 6.1 (page 26)
+/*
+ * BULK_OUT messages from PC to Reader
+ * Defined in CCID Rev 1.1 6.1 (page 26)
  */
 #define CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOn              0x62
 #define CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOff             0x63
@@ -104,8 +113,9 @@ do { if (lvl <= s->debug) { printf("usb-ccid: " fmt , ## __VA_ARGS__); } } while
 #define CCID_MESSAGE_TYPE_PC_to_RDR_Abort                   0x72
 #define CCID_MESSAGE_TYPE_PC_to_RDR_SetDataRateAndClockFrequency 0x73
 
-/* BULK_IN messages from Reader to PC
-   Defined in CCID Rev 1.1 6.2 (page 48)
+/*
+ * BULK_IN messages from Reader to PC
+ * Defined in CCID Rev 1.1 6.2 (page 48)
  */
 #define CCID_MESSAGE_TYPE_RDR_to_PC_DataBlock               0x80
 #define CCID_MESSAGE_TYPE_RDR_to_PC_SlotStatus              0x81
@@ -113,16 +123,18 @@ do { if (lvl <= s->debug) { printf("usb-ccid: " fmt , ## __VA_ARGS__); } } while
 #define CCID_MESSAGE_TYPE_RDR_to_PC_Escape                  0x83
 #define CCID_MESSAGE_TYPE_RDR_to_PC_DataRateAndClockFrequency 0x84
 
-/* INTERRUPT_IN messages from Reader to PC
-   Defined in CCID Rev 1.1 6.3 (page 56)
+/*
+ * INTERRUPT_IN messages from Reader to PC
+ * Defined in CCID Rev 1.1 6.3 (page 56)
  */
 #define CCID_MESSAGE_TYPE_RDR_to_PC_NotifySlotChange        0x50
 #define CCID_MESSAGE_TYPE_RDR_to_PC_HardwareError           0x51
 
-/* Endpoints for CCID - addresses are up to us to decide.
-   To support slot insertion and removal we must have an interrupt in ep
-   in addition we need a bulk in and bulk out ep
-   5.2, page 20
+/*
+ * Endpoints for CCID - addresses are up to us to decide.
+ * To support slot insertion and removal we must have an interrupt in ep
+ * in addition we need a bulk in and bulk out ep
+ * 5.2, page 20
  */
 #define CCID_INT_IN_EP       1
 #define CCID_BULK_IN_EP      2
@@ -145,8 +157,7 @@ enum {
     COMMAND_STATUS_TIME_EXTENSION_REQUIRED
 };
 
-/* Error codes that go in bError (see 6.2.6)
- */
+/* Error codes that go in bError (see 6.2.6) */
 enum {
     ERROR_CMD_NOT_SUPPORTED = 0,
     ERROR_CMD_ABORTED       = -1,
@@ -159,8 +170,9 @@ enum {
 /* 6.2.6 RDR_to_PC_SlotStatus definitions */
 enum {
     CLOCK_STATUS_RUNNING = 0,
-    /* 0 - Clock Running, 1 - Clock stopped in State L, 2 - H,
-       3 - unkonwn state. rest are RFU
+    /*
+     * 0 - Clock Running, 1 - Clock stopped in State L, 2 - H,
+     * 3 - unkonwn state. rest are RFU
      */
 };
 
@@ -248,7 +260,7 @@ typedef struct USBCCIDState USBCCIDState;
 
 #define MAX_PROTOCOL_SIZE   7
 
-/**
+/*
  * powered - defaults to true, changed by PowerOn/PowerOff messages
  */
 struct USBCCIDState {
@@ -256,7 +268,6 @@ struct USBCCIDState {
     CCIDBus *bus;
     CCIDCardState *card;
     CCIDCardInfo *cardinfo; /* caching the info pointer */
-    uint8_t  debug;
     BulkIn bulk_in_pending[BULK_IN_PENDING_NUM]; /* circular */
     uint32_t bulk_in_pending_start;
     uint32_t bulk_in_pending_end; /* first free */
@@ -264,9 +275,6 @@ struct USBCCIDState {
     BulkIn *current_bulk_in;
     uint8_t  bulk_out_data[BULK_OUT_DATA_SIZE];
     uint32_t bulk_out_pos;
-    uint8_t  bmSlotICCState;
-    uint8_t  powered;
-    uint8_t  notify_slot_change;
     uint64_t last_answer_error;
     Answer pending_answers[PENDING_ANSWERS_NUM];
     uint32_t pending_answers_start;
@@ -278,12 +286,17 @@ struct USBCCIDState {
     uint8_t  abProtocolDataStructure[MAX_PROTOCOL_SIZE];
     uint32_t ulProtocolDataStructureSize;
     uint32_t state_vmstate;
-    uint8_t  migration_state;
     uint32_t migration_target_ip;
     uint16_t migration_target_port;
+    uint8_t  migration_state;
+    uint8_t  bmSlotICCState;
+    uint8_t  powered;
+    uint8_t  notify_slot_change;
+    uint8_t  debug;
 };
 
-/* CCID Spec chapter 4: CCID uses a standard device descriptor per Chapter 9,
+/*
+ * CCID Spec chapter 4: CCID uses a standard device descriptor per Chapter 9,
  * "USB Device Framework", section 9.6.1, in the Universal Serial Bus
  * Specification.
  *
@@ -318,128 +331,144 @@ static const uint8_t qemu_ccid_dev_descriptor[] = {
 static const uint8_t qemu_ccid_config_descriptor[] = {
 
         /* one configuration */
-        0x09,       /*  u8  bLength; */
-        USB_DT_CONFIG, /*  u8  bDescriptorType; Configuration */
-        0x5d, 0x00, /*  u16 wTotalLength; 9+9+54+7+7+7 */
-        0x01,       /*  u8  bNumInterfaces; (1) */
-        0x01,       /*  u8  bConfigurationValue; */
-        0x00,       /*  u8  iConfiguration; */
-        0xe0,       /*  u8  bmAttributes;
+        0x09,       /* u8  bLength; */
+        USB_DT_CONFIG, /* u8  bDescriptorType; Configuration */
+        0x5d, 0x00, /* u16 wTotalLength; 9+9+54+7+7+7 */
+        0x01,       /* u8  bNumInterfaces; (1) */
+        0x01,       /* u8  bConfigurationValue; */
+        0x00,       /* u8  iConfiguration; */
+        0xe0,       /* u8  bmAttributes;
                                  Bit 7: must be set,
                                      6: Self-powered,
                                      5: Remote wakeup,
                                      4..0: resvd */
-        100/2,      /*  u8  MaxPower; 50 == 100mA */
+        100/2,      /* u8  MaxPower; 50 == 100mA */
 
         /* one interface */
-        0x09,       /*  u8  if_bLength; */
-        USB_DT_INTERFACE, /*  u8  if_bDescriptorType; Interface */
-        0x00,       /*  u8  if_bInterfaceNumber; */
-        0x00,       /*  u8  if_bAlternateSetting; */
-        0x03,       /*  u8  if_bNumEndpoints; */
-        0x0b,       /*  u8  if_bInterfaceClass; Smart Card Device Class */
-        0x00,       /*  u8  if_bInterfaceSubClass; Subclass code */
-        0x00,       /*  u8  if_bInterfaceProtocol; Protocol code */
-        0x04,       /*  u8  if_iInterface; Index of string descriptor */
+        0x09,       /* u8  if_bLength; */
+        USB_DT_INTERFACE, /* u8  if_bDescriptorType; Interface */
+        0x00,       /* u8  if_bInterfaceNumber; */
+        0x00,       /* u8  if_bAlternateSetting; */
+        0x03,       /* u8  if_bNumEndpoints; */
+        0x0b,       /* u8  if_bInterfaceClass; Smart Card Device Class */
+        0x00,       /* u8  if_bInterfaceSubClass; Subclass code */
+        0x00,       /* u8  if_bInterfaceProtocol; Protocol code */
+        0x04,       /* u8  if_iInterface; Index of string descriptor */
 
         /* Smart Card Device Class Descriptor */
-        0x36,       /*  u8  bLength; */
-        0x21,       /*  u8  bDescriptorType; Functional */
-        0x10, 0x01, /*  u16 bcdCCID; CCID Specification Release Number. */
-        0x00,       /*  u8  bMaxSlotIndex; The index of the highest available
-                        slot on this device. All slots are consecutive starting
-                        at 00h. */
-        0x07,       /*  u8  bVoltageSupport; 01h - 5.0v, 02h - 3.0, 03 - 1.8 */
-
-        0x03, 0x00, /*  u32 dwProtocols; RRRR PPPP. RRRR = 0000h.*/
-        0x00, 0x00, /*  PPPP: 0001h = Protocol T=0, 0002h = Protocol T=1 */
-                    /*  u32 dwDefaultClock; in kHZ (0x0fa0 is 4 MHz) */
+        0x36,       /* u8  bLength; */
+        0x21,       /* u8  bDescriptorType; Functional */
+        0x10, 0x01, /* u16 bcdCCID; CCID Specification Release Number. */
+        0x00,       /*
+                     * u8  bMaxSlotIndex; The index of the highest available
+                     * slot on this device. All slots are consecutive starting
+                     * at 00h.
+                     */
+        0x07,       /* u8  bVoltageSupport; 01h - 5.0v, 02h - 3.0, 03 - 1.8 */
+
+        0x03, 0x00, /* u32 dwProtocols; RRRR PPPP. RRRR = 0000h.*/
+        0x00, 0x00, /* PPPP: 0001h = Protocol T=0, 0002h = Protocol T=1 */
+                    /* u32 dwDefaultClock; in kHZ (0x0fa0 is 4 MHz) */
         0xa0, 0x0f, 0x00, 0x00,
-                    /*  u32 dwMaximumClock; */
+                    /* u32 dwMaximumClock; */
         0x00, 0x00, 0x01, 0x00,
-        0x00,       /*  u8 bNumClockSupported; 0 means just the default and max. */
-                    /*  u32 dwDataRate ;bps. 9600 == 00002580h */
+        0x00,       /* u8 bNumClockSupported;                 *
+                     *    0 means just the default and max.   */
+                    /* u32 dwDataRate ;bps. 9600 == 00002580h */
         0x80, 0x25, 0x00, 0x00,
-                    /*  u32 dwMaxDataRate ; 11520 bps == 0001C200h */
+                    /* u32 dwMaxDataRate ; 11520 bps == 0001C200h */
         0x00, 0xC2, 0x01, 0x00,
-        0x00,       /*  u8  bNumDataRatesSupported; 00 means all rates between
-                     *      default and max */
-                    /*  u32 dwMaxIFSD; maximum IFSD supported by CCID for protocol
-                     *      T=1 (Maximum seen from various cards) */
+        0x00,       /* u8  bNumDataRatesSupported; 00 means all rates between
+                     *     default and max */
+                    /* u32 dwMaxIFSD;                                  *
+                     *     maximum IFSD supported by CCID for protocol *
+                     *     T=1 (Maximum seen from various cards)       */
         0xfe, 0x00, 0x00, 0x00,
-                    /*  u32 dwSyncProtocols; 1 - 2-wire, 2 - 3-wire, 4 - I2C */
+                    /* u32 dwSyncProtocols; 1 - 2-wire, 2 - 3-wire, 4 - I2C */
         0x00, 0x00, 0x00, 0x00,
-                    /*  u32 dwMechanical;  0 - no special characteristics. */
+                    /* u32 dwMechanical;  0 - no special characteristics. */
         0x00, 0x00, 0x00, 0x00,
-                    /*  u32 dwFeatures;
-                     *  0 - No special characteristics
-                     *  + 2 Automatic parameter configuration based on ATR data
-                     *  + 4 Automatic activation of ICC on inserting
-                     *  + 8 Automatic ICC voltage selection
-                     *  + 10 Automatic ICC clock frequency change
-                     *  + 20 Automatic baud rate change
-                     *  + 40 Automatic parameters negotiation made by the CCID
-                     *  + 80 automatic PPS made by the CCID
-                     *  100 CCID can set ICC in clock stop mode
-                     *  200 NAD value other then 00 accepted (T=1 protocol)
-                     *  + 400 Automatic IFSD exchange as first exchange (T=1)
-                     *  One of the following only:
-                     *  + 10000 TPDU level exchanges with CCID
-                     *  20000 Short APDU level exchange with CCID
-                     *  40000 Short and Extended APDU level exchange with CCID
+                    /*
+                     * u32 dwFeatures;
+                     * 0 - No special characteristics
+                     * + 2 Automatic parameter configuration based on ATR data
+                     * + 4 Automatic activation of ICC on inserting
+                     * + 8 Automatic ICC voltage selection
+                     * + 10 Automatic ICC clock frequency change
+                     * + 20 Automatic baud rate change
+                     * + 40 Automatic parameters negotiation made by the CCID
+                     * + 80 automatic PPS made by the CCID
+                     * 100 CCID can set ICC in clock stop mode
+                     * 200 NAD value other then 00 accepted (T=1 protocol)
+                     * + 400 Automatic IFSD exchange as first exchange (T=1)
+                     * One of the following only:
+                     * + 10000 TPDU level exchanges with CCID
+                     * 20000 Short APDU level exchange with CCID
+                     * 40000 Short and Extended APDU level exchange with CCID
                      *
-                     *  + 100000 USB Wake up signaling supported on card insertion
-                     *  and removal. Must set bit 5 in bmAttributes in Configuration
-                     *  descriptor if 100000 is set.*/
+                     * + 100000 USB Wake up signaling supported on card
+                     * insertion and removal. Must set bit 5 in bmAttributes
+                     * in Configuration descriptor if 100000 is set.
+                     */
         0xfe, 0x04, 0x11, 0x00,
-                    /*  u32 dwMaxCCIDMessageLength; For extended APDU in [261 + 10
-                     *  , 65544 + 10]. Otherwise the minimum is wMaxPacketSize of
-                     *  the Bulk-OUT endpoint */
+                    /*
+                     * u32 dwMaxCCIDMessageLength; For extended APDU in
+                     * [261 + 10 , 65544 + 10]. Otherwise the minimum is
+                     * wMaxPacketSize of the Bulk-OUT endpoint
+                     */
         0x12, 0x00, 0x01, 0x00,
-        0xFF,       /*  u8  bClassGetResponse; Significant only for CCID that
-                     *  offers an APDU level for exchanges. Indicates the default
-                     *  class value used by the CCID when it sends a Get Response
-                     *  command to perform the transportation of an APDU by T=0
-                     *  protocol
-                     *  FFh indicates that the CCID echos the class of the APDU.
+        0xFF,       /*
+                     * u8  bClassGetResponse; Significant only for CCID that
+                     * offers an APDU level for exchanges. Indicates the
+                     * default class value used by the CCID when it sends a
+                     * Get Response command to perform the transportation of
+                     * an APDU by T=0 protocol
+                     * FFh indicates that the CCID echos the class of the APDU.
+                     */
+        0xFF,       /*
+                     * u8  bClassEnvelope; EAPDU only. Envelope command for
+                     * T=0
+                     */
+        0x00, 0x00, /*
+                     * u16 wLcdLayout; XXYY Number of lines (XX) and chars per
+                     * line for LCD display used for PIN entry. 0000 - no LCD
                      */
-        0xFF,       /*  u8  bClassEnvelope; EAPDU only. Envelope command for T=0 */
-        0x00, 0x00, /*  u16 wLcdLayout; XXYY Number of lines (XX) and chars per
-                     *  line for LCD display used for PIN entry. 0000 - no LCD */
-        0x01,       /*  u8  bPINSupport; 01h PIN Verification,
-                     *                   02h PIN Modification */
-        0x01,       /*  u8  bMaxCCIDBusySlots; */
+        0x01,       /*
+                     * u8  bPINSupport; 01h PIN Verification,
+                     *                  02h PIN Modification
+                     */
+        0x01,       /* u8  bMaxCCIDBusySlots; */
 
         /* Interrupt-IN endpoint */
-        0x07,       /*  u8  ep_bLength; */
-                    /*  u8  ep_bDescriptorType; Endpoint */
+        0x07,       /* u8  ep_bLength; */
+                    /* u8  ep_bDescriptorType; Endpoint */
         USB_DT_ENDPOINT,
-                    /*  u8  ep_bEndpointAddress; IN Endpoint 1 */
+                    /* u8  ep_bEndpointAddress; IN Endpoint 1 */
         0x80 | CCID_INT_IN_EP,
-        0x03,       /*  u8  ep_bmAttributes; Interrupt */
-                    /*  u16 ep_wMaxPacketSize; */
+        0x03,       /* u8  ep_bmAttributes; Interrupt */
+                    /* u16 ep_wMaxPacketSize; */
         CCID_MAX_PACKET_SIZE & 0xff, (CCID_MAX_PACKET_SIZE >> 8),
-        0xff,       /*  u8  ep_bInterval; */
+        0xff,       /* u8  ep_bInterval; */
 
         /* Bulk-In endpoint */
-        0x07,       /*  u8  ep_bLength; */
-                    /*  u8  ep_bDescriptorType; Endpoint */
+        0x07,       /* u8  ep_bLength; */
+                    /* u8  ep_bDescriptorType; Endpoint */
         USB_DT_ENDPOINT,
-                    /*  u8  ep_bEndpointAddress; IN Endpoint 2 */
+                    /* u8  ep_bEndpointAddress; IN Endpoint 2 */
         0x80 | CCID_BULK_IN_EP,
-        0x02,       /*  u8  ep_bmAttributes; Bulk */
-        0x40, 0x00, /*  u16 ep_wMaxPacketSize; */
-        0x00,       /*  u8  ep_bInterval; */
+        0x02,       /* u8  ep_bmAttributes; Bulk */
+        0x40, 0x00, /* u16 ep_wMaxPacketSize; */
+        0x00,       /* u8  ep_bInterval; */
 
         /* Bulk-Out endpoint */
-        0x07,       /*  u8  ep_bLength; */
-                    /*  u8  ep_bDescriptorType; Endpoint */
+        0x07,       /* u8  ep_bLength; */
+                    /* u8  ep_bDescriptorType; Endpoint */
         USB_DT_ENDPOINT,
-                    /*  u8  ep_bEndpointAddress; OUT Endpoint 3 */
+                    /* u8  ep_bEndpointAddress; OUT Endpoint 3 */
         CCID_BULK_OUT_EP,
-        0x02,       /*  u8  ep_bmAttributes; Bulk */
-        0x40, 0x00, /*  u16 ep_wMaxPacketSize; */
-        0x00,       /*  u8  ep_bInterval; */
+        0x02,       /* u8  ep_bmAttributes; Bulk */
+        0x40, 0x00, /* u16 ep_wMaxPacketSize; */
+        0x00,       /* u8  ep_bInterval; */
 
 };
 
@@ -465,7 +494,7 @@ static void ccid_print_pending_answers(USBCCIDState *s)
         DPRINTF(s, D_VERBOSE, " empty\n");
         return;
     }
-    for (i = s->pending_answers_start, count=s->pending_answers_num ;
+    for (i = s->pending_answers_start, count = s->pending_answers_num ;
          count > 0; count--, i++) {
         answer = &s->pending_answers[i % PENDING_ANSWERS_NUM];
         if (count == 1) {
@@ -478,11 +507,12 @@ static void ccid_print_pending_answers(USBCCIDState *s)
 
 static void ccid_add_pending_answer(USBCCIDState *s, CCID_Header *hdr)
 {
-    Answer* answer;
+    Answer *answer;
 
     assert(s->pending_answers_num < PENDING_ANSWERS_NUM);
     s->pending_answers_num++;
-    answer = &s->pending_answers[(s->pending_answers_end++) % PENDING_ANSWERS_NUM];
+    answer =
+        &s->pending_answers[(s->pending_answers_end++) % PENDING_ANSWERS_NUM];
     answer->slot = hdr->bSlot;
     answer->seq = hdr->bSeq;
     ccid_print_pending_answers(s);
@@ -495,7 +525,8 @@ static void ccid_remove_pending_answer(USBCCIDState *s,
 
     assert(s->pending_answers_num > 0);
     s->pending_answers_num--;
-    answer = &s->pending_answers[(s->pending_answers_start++) % PENDING_ANSWERS_NUM];
+    answer =
+        &s->pending_answers[(s->pending_answers_start++) % PENDING_ANSWERS_NUM];
     *slot = answer->slot;
     *seq = answer->seq;
     ccid_print_pending_answers(s);
@@ -522,28 +553,30 @@ static void ccid_bulk_in_get(USBCCIDState *s)
     }
     assert(s->bulk_in_pending_num > 0);
     s->bulk_in_pending_num--;
-    s->current_bulk_in = &s->bulk_in_pending[
-        (s->bulk_in_pending_start++) % BULK_IN_PENDING_NUM];
+    s->current_bulk_in =
+        &s->bulk_in_pending[(s->bulk_in_pending_start++) % BULK_IN_PENDING_NUM];
 }
 
-static void* ccid_reserve_recv_buf(USBCCIDState* s, uint16_t len)
+static void *ccid_reserve_recv_buf(USBCCIDState *s, uint16_t len)
 {
-    BulkIn* bulk_in;
+    BulkIn *bulk_in;
 
     DPRINTF(s, D_VERBOSE, "%s: QUEUE: reserve %d bytes\n", __func__, len);
 
     /* look for an existing element */
     if (len > BULK_IN_BUF_SIZE) {
-        DPRINTF(s, D_WARN, "usb-ccid.c: %s: len larger then max (%d>%d). discarding message.\n",
-            __func__, len, BULK_IN_BUF_SIZE);
+        DPRINTF(s, D_WARN, "usb-ccid.c: %s: len larger then max (%d>%d). "
+                           "discarding message.\n",
+                           __func__, len, BULK_IN_BUF_SIZE);
         return NULL;
     }
     if (s->bulk_in_pending_num >= BULK_IN_PENDING_NUM) {
-        DPRINTF(s, D_WARN, "usb-ccid.c: %s: No free bulk_in buffers. discarding message.\n",
-                __func__);
+        DPRINTF(s, D_WARN, "usb-ccid.c: %s: No free bulk_in buffers. "
+                           "discarding message.\n", __func__);
         return NULL;
     }
-    bulk_in = &s->bulk_in_pending[(s->bulk_in_pending_end++) % BULK_IN_PENDING_NUM];
+    bulk_in =
+        &s->bulk_in_pending[(s->bulk_in_pending_end++) % BULK_IN_PENDING_NUM];
     s->bulk_in_pending_num++;
     bulk_in->len = len;
     return bulk_in->data;
@@ -575,7 +608,7 @@ static int ccid_handle_control(USBDevice *dev, int request, int value,
     USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);
     int ret = 0;
 
-    DPRINTF(s, 1, "got control %x, value %x\n",request, value);
+    DPRINTF(s, 1, "got control %x, value %x\n", request, value);
     switch (request) {
     case DeviceRequest | USB_REQ_GET_STATUS:
         data[0] = (1 << USB_DEVICE_SELF_POWERED) |
@@ -604,7 +637,7 @@ static int ccid_handle_control(USBDevice *dev, int request, int value,
         ret = 0;
         break;
     case DeviceRequest | USB_REQ_GET_DESCRIPTOR:
-        switch(value >> 8) {
+        switch (value >> 8) {
         case USB_DT_DEVICE:
             memcpy(data, qemu_ccid_dev_descriptor,
                    sizeof(qemu_ccid_dev_descriptor));
@@ -616,7 +649,7 @@ static int ccid_handle_control(USBDevice *dev, int request, int value,
             ret = sizeof(qemu_ccid_config_descriptor);
             break;
         case USB_DT_STRING:
-            switch(value & 0xff) {
+            switch (value & 0xff) {
             case 0:
                 /* language ids */
                 data[0] = 4;
@@ -682,8 +715,9 @@ static int ccid_handle_control(USBDevice *dev, int request, int value,
         ret = USB_RET_STALL;
         break;
     default:
-    fail:
-        DPRINTF(s, 1, "got unsupported/bogus control %x, value %x\n", request, value);
+fail:
+        DPRINTF(s, 1, "got unsupported/bogus control %x, value %x\n",
+                request, value);
         ret = USB_RET_STALL;
         break;
     }
@@ -707,21 +741,22 @@ static uint8_t ccid_card_status(USBCCIDState *s)
 
 static uint8_t ccid_calc_status(USBCCIDState *s)
 {
-    /* page 55, 6.2.6, calculation of bStatus from bmICCStatus and
-       bmCommandStatus
+    /*
+     * page 55, 6.2.6, calculation of bStatus from bmICCStatus and
+     * bmCommandStatus
      */
     uint8_t ret = ccid_card_status(s) | (s->bmCommandStatus << 6);
     DPRINTF(s, D_VERBOSE, "status = %d\n", ret);
     return ret;
 }
 
-static void ccid_reset_error_status(USBCCIDState* s)
+static void ccid_reset_error_status(USBCCIDState *s)
 {
     s->bError = ERROR_CMD_NOT_SUPPORTED;
     s->bmCommandStatus = COMMAND_STATUS_NO_ERROR;
 }
 
-static void ccid_write_slot_status(USBCCIDState* s, CCID_Header* recv)
+static void ccid_write_slot_status(USBCCIDState *s, CCID_Header *recv)
 {
     CCID_SlotStatus *h = ccid_reserve_recv_buf(s, sizeof(CCID_SlotStatus));
     if (h == NULL) {
@@ -737,7 +772,7 @@ static void ccid_write_slot_status(USBCCIDState* s, CCID_Header* recv)
     ccid_reset_error_status(s);
 }
 
-static void ccid_write_parameters(USBCCIDState* s, CCID_Header* recv)
+static void ccid_write_parameters(USBCCIDState *s, CCID_Header *recv)
 {
     CCID_Parameter *h;
     uint32_t len = s->ulProtocolDataStructureSize;
@@ -757,9 +792,8 @@ static void ccid_write_parameters(USBCCIDState* s, CCID_Header* recv)
     ccid_reset_error_status(s);
 }
 
-static void ccid_write_data_block(
-    USBCCIDState* s, uint8_t slot, uint8_t seq,
-    const uint8_t* data, uint32_t len)
+static void ccid_write_data_block(USBCCIDState *s, uint8_t slot, uint8_t seq,
+                                  const uint8_t *data, uint32_t len)
 {
     CCID_DataBlock *p = ccid_reserve_recv_buf(s, sizeof(*p) + len);
 
@@ -779,8 +813,8 @@ static void ccid_write_data_block(
     ccid_reset_error_status(s);
 }
 
-static void ccid_write_data_block_answer(USBCCIDState* s,
-    const uint8_t* data, uint32_t len)
+static void ccid_write_data_block_answer(USBCCIDState *s,
+    const uint8_t *data, uint32_t len)
 {
     uint8_t seq;
     uint8_t slot;
@@ -792,7 +826,7 @@ static void ccid_write_data_block_answer(USBCCIDState* s,
     ccid_write_data_block(s, slot, seq, data, len);
 }
 
-static void ccid_write_data_block_atr(USBCCIDState* s, CCID_Header* recv)
+static void ccid_write_data_block_atr(USBCCIDState *s, CCID_Header *recv)
 {
     const uint8_t *atr = NULL;
     uint32_t len = 0;
@@ -824,10 +858,12 @@ static void ccid_set_parameters(USBCCIDState *s, CCID_Header *recv)
     DPRINTF(s, 1, "%s: using len %d\n", __func__, len);
 }
 
-/* must be 5 bytes for T=0, 7 bytes for T=1
- * See page 52 */
-static const uint8_t abDefaultProtocolDataStructure[7] =
-    { 0x77, 0x00, 0x00, 0x00, 0x00, 0xfe /*IFSC*/, 0x00 /*NAD*/ };
+/*
+ * must be 5 bytes for T=0, 7 bytes for T=1
+ * See page 52
+ */
+static const uint8_t abDefaultProtocolDataStructure[7] = {
+    0x77, 0x00, 0x00, 0x00, 0x00, 0xfe /*IFSC*/, 0x00 /*NAD*/ };
 
 static void ccid_reset_parameters(USBCCIDState *s)
 {
@@ -844,12 +880,10 @@ static void ccid_report_error_failed(USBCCIDState *s, uint8_t error)
     s->bError = error;
 }
 
-/* NOTE: only a single slot is supported (SLOT_0)
- */
-static void ccid_on_slot_change(USBCCIDState* s, bool full)
+/* NOTE: only a single slot is supported (SLOT_0) */
+static void ccid_on_slot_change(USBCCIDState *s, bool full)
 {
-    /* RDR_to_PC_NotifySlotChange, 6.3.1 page 56
-     */
+    /* RDR_to_PC_NotifySlotChange, 6.3.1 page 56 */
     uint8_t current = s->bmSlotICCState;
     if (full) {
         s->bmSlotICCState |= SLOT_0_STATE_MASK;
@@ -873,14 +907,15 @@ static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)
     uint32_t len;
 
     if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {
-        DPRINTF(s, 1, "usb-ccid: not sending apdu to client, no card connected\n");
+        DPRINTF(s, 1,
+                "usb-ccid: not sending apdu to client, no card connected\n");
         ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);
         return;
     }
     len = le32_to_cpu(recv->hdr.dwLength);
-    DPRINTF(s, 1, "%s: seq %d, len %d\n", __FUNCTION__,
+    DPRINTF(s, 1, "%s: seq %d, len %d\n", __func__,
                 recv->hdr.bSeq, len);
-    ccid_add_pending_answer(s, (CCID_Header*)recv);
+    ccid_add_pending_answer(s, (CCID_Header *)recv);
     if (s->card) {
         s->cardinfo->apdu_from_guest(s->card, recv->abData, len);
     } else {
@@ -888,73 +923,82 @@ static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)
     }
 }
 
-/* handle a single USB_TOKEN_OUT, return value returned to guest.
- * 0 - all ok
- * USB_RET_STALL - failed to handle packet */
+/*
+ * Handle a single USB_TOKEN_OUT, return value returned to guest.
+ * Return value:
+ *  0             - all ok
+ *  USB_RET_STALL - failed to handle packet
+ */
 static int ccid_handle_bulk_out(USBCCIDState *s, USBPacket *p)
 {
-    CCID_Header* ccid_header;
+    CCID_Header *ccid_header;
 
     if (p->len + s->bulk_out_pos > BULK_OUT_DATA_SIZE) {
         return USB_RET_STALL;
     }
-    ccid_header = (CCID_Header*)s->bulk_out_data;
+    ccid_header = (CCID_Header *)s->bulk_out_data;
     memcpy(s->bulk_out_data + s->bulk_out_pos, p->data, p->len);
     s->bulk_out_pos += p->len;
     if (p->len == CCID_MAX_PACKET_SIZE) {
-        DPRINTF(s, D_VERBOSE, "usb-ccid: bulk_in: expecting more packets (%d/%d)\n",
+        DPRINTF(s, D_VERBOSE,
+            "usb-ccid: bulk_in: expecting more packets (%d/%d)\n",
             p->len, ccid_header->dwLength);
         return 0;
     }
     if (s->bulk_out_pos < 10) {
-        DPRINTF(s, 1, "%s: bad USB_TOKEN_OUT length, should be at least 10 bytes\n", __func__);
+        DPRINTF(s, 1,
+                "%s: bad USB_TOKEN_OUT length, should be at least 10 bytes\n",
+                __func__);
     } else {
         DPRINTF(s, D_MORE_INFO, "%s %x\n", __func__, ccid_header->bMessageType);
         switch (ccid_header->bMessageType) {
-            case CCID_MESSAGE_TYPE_PC_to_RDR_GetSlotStatus:
-                ccid_write_slot_status(s, ccid_header);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOn:
-                DPRINTF(s, 1, "PowerOn: %d\n",
-                    ((CCID_IccPowerOn*)(ccid_header))->bPowerSelect);
-                s->powered = true;
-                if (!ccid_card_inserted(s)) {
-                    ccid_report_error_failed(s, ERROR_ICC_MUTE);
-                }
-                /* atr is written regardless of error. */
-                ccid_write_data_block_atr(s, ccid_header);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOff:
-                DPRINTF(s, 1, "PowerOff\n");
-                ccid_reset_error_status(s);
-                s->powered = false;
-                ccid_write_slot_status(s, ccid_header);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_XfrBlock:
-                ccid_on_apdu_from_guest(s, (CCID_XferBlock*)s->bulk_out_data);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_SetParameters:
-                ccid_reset_error_status(s);
-                ccid_set_parameters(s, ccid_header);
-                ccid_write_parameters(s, ccid_header);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_ResetParameters:
-                ccid_reset_error_status(s);
-                ccid_reset_parameters(s);
-                ccid_write_parameters(s, ccid_header);
-                break;
-            case CCID_MESSAGE_TYPE_PC_to_RDR_GetParameters:
-                ccid_reset_error_status(s);
-                ccid_write_parameters(s, ccid_header);
-                break;
-            default:
-                DPRINTF(s, 1, "handle_data: ERROR: unhandled message type %Xh\n",
-                    ccid_header->bMessageType);
-                /* the caller is expecting the device to respond, tell it we
-                 * do't support the operation */
-                ccid_report_error_failed(s, ERROR_CMD_NOT_SUPPORTED);
-                ccid_write_slot_status(s, ccid_header);
-                break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_GetSlotStatus:
+            ccid_write_slot_status(s, ccid_header);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOn:
+            DPRINTF(s, 1, "PowerOn: %d\n",
+                ((CCID_IccPowerOn *)(ccid_header))->bPowerSelect);
+            s->powered = true;
+            if (!ccid_card_inserted(s)) {
+                ccid_report_error_failed(s, ERROR_ICC_MUTE);
+            }
+            /* atr is written regardless of error. */
+            ccid_write_data_block_atr(s, ccid_header);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_IccPowerOff:
+            DPRINTF(s, 1, "PowerOff\n");
+            ccid_reset_error_status(s);
+            s->powered = false;
+            ccid_write_slot_status(s, ccid_header);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_XfrBlock:
+            ccid_on_apdu_from_guest(s, (CCID_XferBlock *)s->bulk_out_data);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_SetParameters:
+            ccid_reset_error_status(s);
+            ccid_set_parameters(s, ccid_header);
+            ccid_write_parameters(s, ccid_header);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_ResetParameters:
+            ccid_reset_error_status(s);
+            ccid_reset_parameters(s);
+            ccid_write_parameters(s, ccid_header);
+            break;
+        case CCID_MESSAGE_TYPE_PC_to_RDR_GetParameters:
+            ccid_reset_error_status(s);
+            ccid_write_parameters(s, ccid_header);
+            break;
+        default:
+            DPRINTF(s, 1,
+                "handle_data: ERROR: unhandled message type %Xh\n",
+                ccid_header->bMessageType);
+            /*
+             * The caller is expecting the device to respond, tell it we
+             * don't support the operation.
+             */
+            ccid_report_error_failed(s, ERROR_CMD_NOT_SUPPORTED);
+            ccid_write_slot_status(s, ccid_header);
+            break;
         }
     }
     s->bulk_out_pos = 0;
@@ -975,13 +1019,16 @@ static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
             ccid_bulk_in_release(s);
         }
     } else {
-        ret = USB_RET_NAK; /* return when device has no data - usb 2.0 spec Table 8-4 */
+        /* return when device has no data - usb 2.0 spec Table 8-4 */
+        ret = USB_RET_NAK;
     }
     if (ret > 0) {
-        DPRINTF(s, D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, len, ret);
+        DPRINTF(s, D_MORE_INFO,
+                "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, len, ret);
     }
     if (ret != USB_RET_NAK && ret < len) {
-        DPRINTF(s, 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, len);
+        DPRINTF(s, 1,
+            "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, len);
     }
     return ret;
 }
@@ -1000,28 +1047,30 @@ static int ccid_handle_data(USBDevice *dev, USBPacket *p)
 
     case USB_TOKEN_IN:
         switch (p->devep & 0xf) {
-            case CCID_BULK_IN_EP:
-                if (!len) {
-                    ret = USB_RET_NAK;
-                } else {
-                    ret = ccid_bulk_in_copy_to_guest(s, data, len);
-                }
-                break;
-            case CCID_INT_IN_EP:
-                if (s->notify_slot_change) {
-                    /* page 56, RDR_to_PC_NotifySlotChange */
-                    data[0] = CCID_MESSAGE_TYPE_RDR_to_PC_NotifySlotChange;
-                    data[1] = s->bmSlotICCState;
-                    ret = 2;
-                    s->notify_slot_change = false;
-                    s->bmSlotICCState &= ~SLOT_0_CHANGED_MASK;
-                    DPRINTF(s, D_INFO, "handle_data: int_in: notify_slot_change %X, requested len %d\n",
-                            s->bmSlotICCState, len);
-                }
-                break;
-            default:
-                DPRINTF(s, 1, "Bad endpoint\n");
-                break;
+        case CCID_BULK_IN_EP:
+            if (!len) {
+                ret = USB_RET_NAK;
+            } else {
+                ret = ccid_bulk_in_copy_to_guest(s, data, len);
+            }
+            break;
+        case CCID_INT_IN_EP:
+            if (s->notify_slot_change) {
+                /* page 56, RDR_to_PC_NotifySlotChange */
+                data[0] = CCID_MESSAGE_TYPE_RDR_to_PC_NotifySlotChange;
+                data[1] = s->bmSlotICCState;
+                ret = 2;
+                s->notify_slot_change = false;
+                s->bmSlotICCState &= ~SLOT_0_CHANGED_MASK;
+                DPRINTF(s, D_INFO,
+                        "handle_data: int_in: notify_slot_change %X, "
+                        "requested len %d\n",
+                        s->bmSlotICCState, len);
+            }
+            break;
+        default:
+            DPRINTF(s, 1, "Bad endpoint\n");
+            break;
         }
         break;
     default:
@@ -1040,7 +1089,8 @@ static void ccid_handle_destroy(USBDevice *dev)
     ccid_bulk_in_clear(s);
 }
 
-static void ccid_flush_pending_answers(USBCCIDState *s) {
+static void ccid_flush_pending_answers(USBCCIDState *s)
+{
     while (ccid_has_pending_answers(s)) {
         ccid_write_data_block_answer(s, NULL, 0);
     }
@@ -1087,9 +1137,11 @@ static CCIDBus *ccid_bus_new(DeviceState *dev)
     return bus;
 }
 
-void ccid_card_send_apdu_to_guest(CCIDCardState *card, uint8_t* apdu, uint32_t len)
+void ccid_card_send_apdu_to_guest(CCIDCardState *card,
+                                  uint8_t *apdu, uint32_t len)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev,
+                                card->qdev.parent_bus->parent);
     Answer *answer;
 
     if (!ccid_has_pending_answers(s)) {
@@ -1108,7 +1160,8 @@ void ccid_card_send_apdu_to_guest(CCIDCardState *card, uint8_t* apdu, uint32_t l
 
 void ccid_card_card_removed(CCIDCardState *card)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     ccid_on_slot_change(s, false);
     ccid_flush_pending_answers(s);
@@ -1117,7 +1170,8 @@ void ccid_card_card_removed(CCIDCardState *card)
 
 int ccid_card_ccid_attach(CCIDCardState *card)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     DPRINTF(s, 1, "CCID Attach\n");
     if (s->migration_state == MIGRATION_MIGRATED) {
@@ -1128,7 +1182,8 @@ int ccid_card_ccid_attach(CCIDCardState *card)
 
 void ccid_card_ccid_detach(CCIDCardState *card)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     DPRINTF(s, 1, "CCID Detach\n");
     if (ccid_card_inserted(s)) {
@@ -1139,15 +1194,17 @@ void ccid_card_ccid_detach(CCIDCardState *card)
 
 void ccid_card_card_error(CCIDCardState *card, uint64_t error)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     s->bmCommandStatus = COMMAND_STATUS_FAILED;
     s->last_answer_error = error;
     DPRINTF(s, 1, "VSC_Error: %lX\n", s->last_answer_error);
-    /* TODO: these error's should be more verbose and propogated to the guest.
-     * */
-    /* we flush all pending answers on CardRemove message in ccid-card-passthru,
-     * so check that first to not trigger abort */
+    /* TODO: these error's should be more verbose and propogated to the guest.*/
+    /*
+     * We flush all pending answers on CardRemove message in ccid-card-passthru,
+     * so check that first to not trigger abort
+     */
     if (ccid_has_pending_answers(s)) {
         ccid_write_data_block_answer(s, NULL, 0);
     }
@@ -1155,7 +1212,8 @@ void ccid_card_card_error(CCIDCardState *card, uint64_t error)
 
 void ccid_card_card_inserted(CCIDCardState *card)
 {
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     s->bmCommandStatus = COMMAND_STATUS_NO_ERROR;
     ccid_flush_pending_answers(s);
@@ -1167,7 +1225,8 @@ static int ccid_card_exit(DeviceState *qdev)
     int ret = 0;
     CCIDCardState *card = DO_UPCAST(CCIDCardState, qdev, qdev);
     CCIDCardInfo *info = DO_UPCAST(CCIDCardInfo, qdev, qdev->info);
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
 
     if (ccid_card_inserted(s)) {
         ccid_card_card_removed(card);
@@ -1184,7 +1243,8 @@ static int ccid_card_init(DeviceState *qdev, DeviceInfo *base)
 {
     CCIDCardState *card = DO_UPCAST(CCIDCardState, qdev, qdev);
     CCIDCardInfo *info = DO_UPCAST(CCIDCardInfo, qdev, base);
-    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
+    USBCCIDState *s =
+        DO_UPCAST(USBCCIDState, dev.qdev, card->qdev.parent_bus->parent);
     int ret = 0;
 
     if (card->slot != 0) {
@@ -1241,10 +1301,12 @@ static int ccid_post_load(void *opaque, int version_id)
 {
     USBCCIDState *s = opaque;
 
-    // This must be done after usb_device_attach, which sets state to ATTACHED,
-    // while it must be DEFAULT in order to accept packets (like it is after
-    // reset, but reset will reset our addr and call our reset handler which
-    // may change state, and we don't want to do that when migrating).
+    /*
+     * This must be done after usb_device_attach, which sets state to ATTACHED,
+     * while it must be DEFAULT in order to accept packets (like it is after
+     * reset, but reset will reset our addr and call our reset handler which
+     * may change state, and we don't want to do that when migrating).
+     */
     s->dev.state = s->state_vmstate;
     return 0;
 }
@@ -1255,8 +1317,10 @@ static void ccid_pre_save(void *opaque)
 
     s->state_vmstate = s->dev.state;
     if (s->dev.attached) {
-        // migrating an open device, ignore reconnection CHR_EVENT to avoid an
-        // erronous detach.
+        /*
+         * Migrating an open device, ignore reconnection CHR_EVENT to avoid an
+         * erronous detach.
+         */
         s->migration_state = MIGRATION_MIGRATED;
     }
 }
@@ -1265,7 +1329,7 @@ static VMStateDescription bulk_in_vmstate = {
     .name = "CCID BulkIn state",
     .version_id = 1,
     .minimum_version_id = 1,
-    .fields = (VMStateField []) {
+    .fields = (VMStateField[]) {
         VMSTATE_BUFFER(data, BulkIn),
         VMSTATE_UINT32(len, BulkIn),
         VMSTATE_UINT32(pos, BulkIn),
@@ -1277,7 +1341,7 @@ static VMStateDescription answer_vmstate = {
     .name = "CCID Answer state",
     .version_id = 1,
     .minimum_version_id = 1,
-    .fields = (VMStateField []) {
+    .fields = (VMStateField[]) {
         VMSTATE_UINT8(slot, Answer),
         VMSTATE_UINT8(seq, Answer),
         VMSTATE_END_OF_LIST()
@@ -1288,7 +1352,7 @@ static VMStateDescription usb_device_vmstate = {
     .name = "usb_device",
     .version_id = 1,
     .minimum_version_id = 1,
-    .fields = (VMStateField []) {
+    .fields = (VMStateField[]) {
         VMSTATE_UINT8(addr, USBDevice),
         VMSTATE_BUFFER(setup_buf, USBDevice),
         VMSTATE_BUFFER(data_buf, USBDevice),
@@ -1302,7 +1366,7 @@ static VMStateDescription ccid_vmstate = {
     .minimum_version_id = 1,
     .post_load = ccid_post_load,
     .pre_save = ccid_pre_save,
-    .fields = (VMStateField []) {
+    .fields = (VMStateField[]) {
         VMSTATE_STRUCT(dev, USBCCIDState, 1, usb_device_vmstate, USBDevice),
         VMSTATE_UINT8(debug, USBCCIDState),
         VMSTATE_BUFFER(bulk_out_data, USBCCIDState),
-- 
1.7.3.2

